<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>ZPT reference </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="ZPT reference ">
    <meta name="generator" content="docfx 2.56.6.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="zpt-reference">ZPT reference</h1>

<p>The ZPT syntax/language is organised into three logical parts.
Each primary mention of an attribute below is a link to its reference page.</p>
<h2 id="metal-is-for-reusing-markup">METAL is for reusing markup</h2>
<p>When processing a ZPT source document, the first attributes processed (through the entire document) are METAL attributes.
<em>Only once all METAL attributes are processed</em> does ZptSharp process TAL attributes.</p>
<p>The concept at the heart of METAL is <strong>macros</strong>. A macro is a reusable subtree of an HTML or XML document. In other words, it is an element and all of that element's descendents &amp; content. Macros are created using <a href="Metal/DefineMacro.html">the <code>metal:define-macro</code> attribute</a> and reused within a document with <a href="Metal/UseMacro.html">the <code>metal:use-macro</code> attribute</a>.</p>
<p>METAL macros may also contain zero or more <strong>slots</strong>. Slots are also single elements which may be replaced ('filled') at the point where the macro is used. Slots are created with <a href="Metal/DefineSlot.html">the <code>metal:define-slot</code> attribute</a> and are used/filled using <a href="Metal/FillSlot.html">the <code>metal:fill-slot</code> attribute</a>.</p>
<p>An advanced usage of METAL is <em>macro extension</em>. This is somewhat similar in concept to creating a 'subclass' of a macro. <a href="Metal/ExtendMacro.html">The <code>metal:extend-macro</code> attribute</a> is how this is performed.</p>
<h2 id="tal-binds-data-to-the-template">TAL binds data to the template</h2>
<p>TAL attributes are parsed and resolved after METAL attributes. The purpose of TAL is to bind/write your model and supporting data to the template.</p>
<p>The table below shows and links to the various TAL attributes.
It also shows the order in which they are processed (if, for example, multiple attributes appear on the same element).</p>
<table>
<thead>
<tr>
<th>Order</th>
<th>Attribute</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td>1st</td>
<td><a href="Tal/Define.html"><code>tal:define</code></a></td>
<td>Creates variables which are usable by subsequent directives.</td>
</tr>
<tr>
<td>2nd</td>
<td><a href="Tal/Condition.html"><code>tal:condition</code></a></td>
<td>Removes the element if the associated expression is not &quot;truthy&quot;</td>
</tr>
<tr>
<td>3rd</td>
<td><a href="Tal/Repeat.html"><code>tal:repeat</code></a></td>
<td>Repeats the element (and contents) for each item in an <code>IEnumerable</code></td>
</tr>
<tr>
<td>4th*</td>
<td><a href="Tal/ContentAndReplace.html"><code>tal:content</code></a></td>
<td>Replaces the element's contents with a value from an expression</td>
</tr>
<tr>
<td>4th*</td>
<td><a href="Tal/ContentAndReplace.html"><code>tal:replace</code></a></td>
<td>Replaces the whole element with a value from an expression</td>
</tr>
<tr>
<td>5th</td>
<td><a href="Tal/Attributes.html"><code>tal:attributes</code></a></td>
<td>Sets attributes upon the element using expression values</td>
</tr>
<tr>
<td>6th</td>
<td><a href="Tal/OmitTag.html"><code>tal:omit-tag</code></a></td>
<td>Removes the start &amp; end tags of an element, whilst preserving its content/children</td>
</tr>
<tr>
<td>N/A**</td>
<td><a href="Tal/OnError.html"><code>tal:on-error</code></a></td>
<td>Handles processing errors on the current element and children (similar to a C# <code>catch</code>)</td>
</tr>
</tbody>
</table>
<h3 id="notes-for-the-above-table">Notes for the above table</h3>
<ul>
<li>* TAL content and replace attributes are <em>mutually exclusive</em>. It is invalid for the same element to have both.</li>
<li>** The on-error attribute <em>does not fit into the usual order of processing</em>. It is only processed if/when an error occurs.</li>
</ul>
<h2 id="tales-is-how-expressions-are-written">TALES is how expressions are written</h2>
<p>Both METAL and TAL attributes make use of expressions to locate the desired macros, content or logic.
TALES is <em>an extensible syntax</em> and so plugins may add further expression types. These are the expression types which are officially supported by ZptSharp.</p>
<p>In the examples below all expressions are shown <em>using their fully qualified/prefixed names</em>.  Every rendering operation has <em>a default expression type</em> which does not require a prefix.  If not specified otherwise <a class="xref" href="../../api/ZptSharp.Config.RenderingConfig.html#ZptSharp_Config_RenderingConfig_DefaultExpressionType">using the configuration</a>, this default type will be <strong>path</strong> expressions.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Tales/PathExpressions.html"><code>path</code></a></td>
<td>Provide access to objects using a syntax which looks a lot like the path portion of a URL.  For example <code>path:here/Customers/3/Name</code></td>
</tr>
<tr>
<td><a href="Tales/StringExpressions.html"><code>string</code></a></td>
<td>Create interpolated strings including content from other expressions.  For example <code>string:Hello ${path:name}, how are you?</code></td>
</tr>
<tr>
<td><a href="Tales/NotExpressions.html"><code>not</code></a></td>
<td>Coerce another expression result to boolean, then negate it.  For example <code>not:path:loan/IsOverdue</code></td>
</tr>
<tr>
<td><a href="Tales/PipeExpressions.html"><code>pipe</code></a></td>
<td>Use a delegate to transform a value.  For example <code>pipe:name path:pipes/ToLowercase</code></td>
</tr>
<tr>
<td><a href="Tales/CSharpExpressions.html"><code>csharp</code></a></td>
<td>Evaluate arbitrary C# expressions (but <em><a href="Tales/CSharpExpressionLimitations.html">please read about the limitations</a></em>).  For example <code>csharp:name.ToLowerInvariant()</code></td>
</tr>
<tr>
<td><a href="Tales/PythonExpressions.html"><code>python</code></a></td>
<td>Evaluate arbitrary expressions written in the Python 2 language.  For example <code>python:2 + 2</code></td>
</tr>
<tr>
<td><a href="Tales/StructureExpressions.html"><code>structure</code></a></td>
<td>Indicates that an 'inner' expression should be interpreted as structure/markup when rendered.  For example <code>structure:path:here/SomeMarkup</code></td>
</tr>
</tbody>
</table>
<h2 id="in-xml-documents-namespaces-matter">In XML documents, namespaces matter</h2>
<p>The <code>metal</code> and <code>tal</code> attribute prefixes used throughout ZPT are defined with the following XML namespaces:</p>
<table>
<thead>
<tr>
<th>Prefix</th>
<th>Namespace</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>metal</code></td>
<td><code>http://xml.zope.org/namespaces/metal</code></td>
</tr>
<tr>
<td><code>tal</code></td>
<td><code>http://xml.zope.org/namespaces/tal</code></td>
</tr>
</tbody>
</table>
<p>When working with XML document templates, these two namespaces must be declared (typically at the root of the document) via <code>xmlns</code> attributes.
Strictly-speaking, for an XML document <em>the namespaces are all that matters</em>, you could conveivably use aliases which are not <code>tal</code> or <code>metal</code>, although for readability's sake this is not advised.</p>
<p>When using HTML documents <em>the namespaces need not be declared</em>; the <code>metal</code> and <code>tal</code> prefixes are recognised by their prefix names alone.</p>
<h3 id="xml-namespaces-example">XML namespaces example</h3>
<pre><code class="lang-xml">&lt;root xmlns:metal=&quot;http://xml.zope.org/namespaces/metal&quot;
      xmlns:tal=&quot;http://xml.zope.org/namespaces/tal&quot;&gt;
    &lt;child tal:content=&quot;string:Some content&quot;&gt;This content attribute will work OK.&lt;/child&gt;
&lt;/root&gt;
</code></pre>
<h2 id="elements-in-the-tal-or-metal-namespace">Elements in the TAL or METAL namespace</h2>
<p>A feature of the ZPT syntax is elements which use the <code>tal</code> or <code>metal</code> prefix (or, for XML documents, elements in the namespaces listed in the previous section).</p>
<p>Elements which are prefixed with either <code>tal</code> or <code>metal</code> may be 'invented' by the designer, the element name after the prefix is irrelevant.
Such elements are detected by ZptSharp during rendering and their start/end tags are <a href="Tal/OmitTag.html">always omitted from the rendered output as if they had a <code>tal:omit-tag=&quot;&quot;</code> attribute</a> present.
What's more, all attributes upon a TAL or METAL element are automatically assumed to be TAL or METAL attributes (accordingly).
This means that within such an element, the <code>tal:</code> or <code>metal:</code> prefixes are not required for attributes.</p>
<p>The use-case for TAL &amp; METAL elements is to allow use of TAL &amp; METAL attributes in positions <em>where no other markup element would semantically make sense</em>.
This scenario does not occur very often and so it is not expected that this technique will be frequently used.</p>
<h3 id="tal-element-example">TAL element example</h3>
<p>Here is a somewhat contrived example.
For the purpose of this example, presume that we cannot alter the <code>&lt;ul&gt;</code> element and add attributes to it.
Perhaps the <code>&lt;ul&gt;</code> element is part of a macro which we do not wish to alter.</p>
<pre><code class="lang-html">&lt;ul&gt;
  &lt;tal:defs define=&quot;items here/Items | here/OtherItems | here/EmptyArray&quot;&gt;
    &lt;li tal:repeat=&quot;item items&quot; tal:content=&quot;item/Name&quot;&gt;Item name&lt;/li&gt;
  &lt;/tal:defs&gt;
&lt;/ul&gt;
</code></pre>
<p>In a real application, we could more likely add <a href="Tal/Define.html">the complex <code>tal:define</code> attribute</a> onto the <code>&lt;li&gt;</code> element.
Because define attributes are processed before content attributes we would get the same result without needing a TAL element.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/csf-dev/ZPT-Sharp/blob/master/ZptSharp.Documentation/articles/ZptReference/Index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
