<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSF.Utils</name>
    </assembly>
    <members>
        <member name="T:CSF.Int32Extensions">
            <summary>
            <para>Provider for extension methods relating to <see cref="T:System.Int32"/>.</para>
            </summary>
        </member>
        <member name="M:CSF.Int32Extensions.GenerateAlphabeticReference(System.Int32)">
            <summary>
            <para>
            Overloaded.  Creates a lowercase alphabetic reference for the given <see cref="T:System.Int32"/> using a
            zero-based generation strategy.
            </para>
            </summary>
            <remarks>
            <para>
            This method creates an alphabetic reference from an integer.  This is essentially a base-26 representation of
            the integer.
            </para>
            <para>
            There is one caveat, which is that the alphabet has no character to represent zero.  This means that (using
            the default strategy used by this overload) <c>a</c> represents zero, <c>aa</c> represents 25 and so on.  If
            non-zero-based operation is required then you should instead look to
            <c>GenerateAlphabeticReference(int, bool)</c> in order to make use of the alternative strategy.
            </para>
            </remarks>
            <param name="integerValue">
            A <see cref="T:System.Int32"/> to represent as an alphabetic string.
            </param>
            <returns>
            A <see cref="T:System.String"/>, the generated alphabetic reference.
            </returns>
            <exception cref="T:System.NotSupportedException">
            <para>If <paramref name="integerValue"/> is less than zero.</para>
            </exception>
        </member>
        <member name="M:CSF.Int32Extensions.GenerateAlphabeticReference(System.Int32,System.Boolean)">
            <summary>
            <para>
            Overloaded.  Creates a lowercase alphabetic reference for the given <see cref="T:System.Int32"/> using the
            generation strategy specified by <paramref name="zeroBased"/>.
            </para>
            </summary>
            <remarks>
            <para>
            This method creates an alphabetic reference from an integer.  This is essentially a base-26 representation of
            the integer.
            </para>
            <para>
            This method offers two distinct strategies for generating the alphabetic reference.  The strategy used is
            controlled by the value of <paramref name="zeroBased"/>:
            </para>
            <list type="table">
            <listheader>
            <term>Strategy</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Non-zero-based</term>
            <description>
            The generated alphabetic reference is based at one.  For example: <c>a</c> represents one, <c>c</c> represents
            three and so on.  Non-zero-based generation supports the generation of references that represent negative
            numbers (the minus symbol is prepended to the generated result).  The drawback of this approach is that the
            value of zero is represented by <see cref="F:System.String.Empty"/>.
            </description>
            </item>
            <item>
            <term>Zero-based</term>
            <description>
            The generated alphabetic reference is based at zero.  For example: <c>a</c> represents zero, <c>c</c>
            represents two and so on.  Zero-based generation does not support the generation of reference that represent
            negative numbers (attempting this will result in an exception being raised).  Zero-based generation does
            however ensure that the output will never be an empty string.
            </description>
            </item>
            </list>
            <example>
            <para>
            For example, using the zero-based strategy then the input <c>500</c> will result in the alphabetic reference
            <c>tg</c>.  The workings for this are shown below:
            <code>
            "g" is the 6th character in sequence (zero-based).
            If "a" is zero then at the zero'th character position (right-to-left) "g" represents:  6×(26^0)  = 6×1   = 6
            
            "t" is the 19th character in sequence (zero-based).
            If "a" is zero then at the first character position (right-to-left) "t" represents:    19×(26^1) = 19×26 = 494
            
            The final result is 494 + 6 = 500.
            </code>
            </para>
            <para>
            Using the non-zero-based strategy then the input <c>500</c> will result in the alphabetic reference <c>sf</c>.
            The workings for this are shown below:
            <code>
            "f" is the 6th character in sequence (one-based).
            If "a" is one then at the zero'th character position (right-to-left) "f" represents:   6×(26^0)  = 6×1   = 6
            
            "s" is the 19th character in sequence (one-based).
            If "a" is one then at the first character position (right-to-left) "s" represents:     19×(26^1) = 19×26 = 494
            
            The final result is 494 + 6 = 500.
            </code>
            </para>
            </example>
            <para>An example of the </para>
            </remarks>
            <param name="integerValue">
            A <see cref="T:System.Int32"/> to represent as an alphabetic string.
            </param>
            <param name="zeroBased">
            A <see cref="T:System.Boolean"/> that indicates the generation strategy to use.  If this is true then a
            zero-based strategy will be used, if false then a non-zero-based strategy will be used.
            </param>
            <returns>
            A <see cref="T:System.String"/>, the generated alphabetic reference.  This will equal <see cref="F:System.String.Empty"/>
            in the scenario that both <paramref name="zeroBased"/> is false and the <paramref name="integerValue"/> is
            zero.
            </returns>
            <exception cref="T:System.NotSupportedException">
            <para>
            If both <paramref name="zeroBased"/> is true and <paramref name="integerValue"/> is less than zero, see the
            remarks for more information.
            </para>
            </exception>
        </member>
        <member name="M:CSF.Int32Extensions.ParseAlphabeticReference(System.String)">
            <summary>
            Parses a <see cref="T:System.String"/> alphabetic reference to a number as a <see cref="T:System.Int32"/>.
            </summary>
            <remarks>
            <para>
            This method is essentially the inverse of <c>GenerateAlphabeticReference(int)</c>, see the documentation
            for that method for more information on how these references work.
            </para>
            </remarks>
            <returns>
            The <see cref="T:System.Int32"/> representation of the alphabetic reference.
            </returns>
            <param name='reference'>
            The alphabetic reference to parse
            </param>
        </member>
        <member name="M:CSF.Int32Extensions.ParseAlphabeticReference(System.String,System.Boolean)">
            <summary>
            Parses a <see cref="T:System.String"/> alphabetic reference to a number as a <see cref="T:System.Int32"/>.
            </summary>
            <returns>
            The <see cref="T:System.Int32"/> representation of the alphabetic reference.
            </returns>
            <param name='reference'>
            The alphabetic reference to parse
            </param>
            <param name='zeroBased'>
            Whether or not to use the zero-based method for parsing the reference or not.
            </param>
            <exception cref='T:System.ArgumentNullException'>
            Is thrown when an argument passed to a method is invalid because it is <see langword="null" /> .
            </exception>
            <exception cref='T:System.FormatException'>
            Represents errors caused by passing incorrectly formatted arguments or invalid format specifiers to methods.
            </exception>
        </member>
        <member name="M:CSF.Int32Extensions.GetBitNumbers(System.Int32)">
            <summary>
            Gets a collection of the decimal bit numbers that would represent the binary bits that make up the binary
            representation of the input.
            </summary>
            <remarks>
            <para>
            This method returns the input <paramref name="integerValue"/> broken down into a collection of
            <see cref="T:System.Int32"/> values which - when added together - would equal the original input value.  The
            output values are all decimal representations of binary bit numbers (IE: powers of two).
            </para>
            <example>
            If the value <c>45</c> were passed into this method, the output would be the collection of integers:
            <c>{ 1, 4, 8, 32 }</c>.  These correspond to the bits <c>101101</c> (which is the binary representation of
            <c>45</c>).
            </example>
            <para>
            If the input to this method is negative then all of the output bits will also be negative.
            </para>
            </remarks>
            <returns>
            The bit numbers.
            </returns>
            <param name='integerValue'>
            The value for which to get the bit numbers.
            </param>
        </member>
        <member name="M:CSF.Int32Extensions.GenerateAlphabeticReference(System.Int32,System.Int32,System.Text.StringBuilder@,System.Boolean)">
            <summary>
            <para>
            Overloaded.  Private 'worker' method creates a lowercase alphabetic reference for the given
            <see cref="T:System.Int32"/>, starting from the given <paramref name="currentCharacterPosition"/>.  The resulting
            reference is written to a <see cref="T:System.Text.StringBuilder"/>.
            </para>
            </summary>
            <remarks>
            <para>
            This method is recursive within itself; it will recurse as many times as required, incrementing
            <paramref name="currentCharacterPosition"/> by one with each iteration until no more iterations are required.
            Each iteration prepends a new character to the <paramref name="output"/> and one iteration is completed for
            each power of 26 (the length of the alphabet) that the the <paramref name="targetValue"/> divides into.
            </para>
            <para>
            The <paramref name="currentCharacterPosition"/> indicates the position of the current character that is being
            generated.  This is zero based and reads from right-to-left (from the least significant character to the most).
            <example>
            <code>
            abc
              ^ this is character position zero
            </code>
            </example>
            <example>
            <code>
            abc
            ^   this is character position two
            </code>
            </example>
            </para>
            </remarks>
            <param name="targetValue">
            A <see cref="T:System.Int32"/> to represent as an alphabetic string.
            </param>
            <param name="currentCharacterPosition">
            A <see cref="T:System.Int32"/> indicating the position of the character that this iteration should generate.
            This value is zero-based and indicates a character reading from right-to-left.
            </param>
            <param name="output">
            A <see cref="T:System.Text.StringBuilder"/> that the output is written to.
            </param>
            <param name="zeroBased">
            A <see cref="T:System.Boolean"/> that indicates whether or not zero-based character references should be used
            or not.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>Either:</para>
            <list type="bullet">
            <item>The <paramref name="targetValue"/> is less than zero.</item>
            <item><paramref name="zeroBased"/> is false and the <paramref name="targetValue"/> is less than one.</item>
            <item>The <paramref name="currentCharacterPosition"/> is less than zero.</item>
            </list>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <para>The <paramref name="output"/> is null.</para>
            </exception>
        </member>
        <member name="M:CSF.Int32Extensions.ToAlphabeticReference(System.Int32)">
            <summary>
            <para>
            Overloaded.  Creates a lowercase alphabetic reference for the given <see cref="T:System.Int32"/> using a
            zero-based generation strategy.
            </para>
            </summary>
            <remarks>
            <para>
            This method creates an alphabetic reference from an integer.  This is essentially a base-26 representation of
            the integer.
            </para>
            <para>
            There is one caveat, which is that the alphabet has no character to represent zero.  This means that (using
            the default strategy used by this overload) <c>a</c> represents zero, <c>aa</c> represents 25 and so on.  If
            non-zero-based operation is required then you should instead look to
            <c>GenerateAlphabeticReference(int, bool)</c> in order to make use of the alternative strategy.
            </para>
            </remarks>
            <returns>
            A <see cref="T:System.String"/>, the generated alphabetic reference.
            </returns>
            <param name='number'>
            The number to turn into an alphabetic reference.
            </param>
        </member>
        <member name="M:CSF.Int32Extensions.ToAlphabeticReference(System.Int32,System.Boolean)">
            <summary>
            <para>
            Overloaded.  Creates a lowercase alphabetic reference for the given <see cref="T:System.Int32"/> using the
            generation strategy specified by <paramref name="zeroBased"/>.
            </para>
            </summary>
            <remarks>
            <para>
            This method creates an alphabetic reference from an integer.  This is essentially a base-26 representation of
            the integer.
            </para>
            <para>
            This method offers two distinct strategies for generating the alphabetic reference.  The strategy used is
            controlled by the value of <paramref name="zeroBased"/>:
            </para>
            <list type="table">
            <listheader>
            <term>Strategy</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Non-zero-based</term>
            <description>
            The generated alphabetic reference is based at one.  For example: <c>a</c> represents one, <c>c</c> represents
            three and so on.  Non-zero-based generation supports the generation of references that represent negative
            numbers (the minus symbol is prepended to the generated result).  The drawback of this approach is that the
            value of zero is represented by <see cref="F:System.String.Empty"/>.
            </description>
            </item>
            <item>
            <term>Zero-based</term>
            <description>
            The generated alphabetic reference is based at zero.  For example: <c>a</c> represents zero, <c>c</c>
            represents two and so on.  Zero-based generation does not support the generation of reference that represent
            negative numbers (attempting this will result in an exception being raised).  Zero-based generation does
            however ensure that the output will never be an empty string.
            </description>
            </item>
            </list>
            <example>
            <para>
            For example, using the zero-based strategy then the input <c>500</c> will result in the alphabetic reference
            <c>tg</c>.  The workings for this are shown below:
            <code>
            "g" is the 6th character in sequence (zero-based).
            If "a" is zero then at the zero'th character position (right-to-left) "g" represents:  6×(26^0)  = 6×1   = 6
            
            "t" is the 19th character in sequence (zero-based).
            If "a" is zero then at the first character position (right-to-left) "t" represents:    19×(26^1) = 19×26 = 494
            
            The final result is 494 + 6 = 500.
            </code>
            </para>
            <para>
            Using the non-zero-based strategy then the input <c>500</c> will result in the alphabetic reference <c>sf</c>.
            The workings for this are shown below:
            <code>
            "f" is the 6th character in sequence (one-based).
            If "a" is one then at the zero'th character position (right-to-left) "f" represents:   6×(26^0)  = 6×1   = 6
            
            "s" is the 19th character in sequence (one-based).
            If "a" is one then at the first character position (right-to-left) "s" represents:     19×(26^1) = 19×26 = 494
            
            The final result is 494 + 6 = 500.
            </code>
            </para>
            </example>
            <para>An example of the </para>
            </remarks>
            <param name="number">
            A <see cref="T:System.Int32"/> to represent as an alphabetic string.
            </param>
            <param name="zeroBased">
            A <see cref="T:System.Boolean"/> that indicates the generation strategy to use.  If this is true then a
            zero-based strategy will be used, if false then a non-zero-based strategy will be used.
            </param>
            <returns>
            A <see cref="T:System.String"/>, the generated alphabetic reference.  This will equal <see cref="F:System.String.Empty"/>
            in the scenario that both <paramref name="zeroBased"/> is false and the <paramref name="number"/> is
            zero.
            </returns>
            <exception cref="T:System.NotSupportedException">
            <para>
            If both <paramref name="zeroBased"/> is true and <paramref name="number"/> is less than zero, see the
            remarks for more information.
            </para>
            </exception>
        </member>
        <member name="M:CSF.Int32Extensions.ToBitNumbers(System.Int32)">
            <summary>
            Gets a collection of the decimal bit numbers that would represent the binary bits that make up the binary
            representation of the input.
            </summary>
            <remarks>
            <para>
            This method returns the input <paramref name="number"/> broken down into a collection of
            <see cref="T:System.Int32"/> values which - when added together - would equal the original input value.  The
            output values are all decimal representations of binary bit numbers (IE: powers of two).
            </para>
            <example>
            If the value <c>45</c> were passed into this method, the output would be the collection of integers:
            <c>{ 1, 4, 8, 32 }</c>.  These correspond to the bits <c>101101</c> (which is the binary representation of
            <c>45</c>).
            </example>
            <para>
            If the input to this method is negative then all of the output bits will also be negative.
            </para>
            </remarks>
            <returns>
            The bit numbers.
            </returns>
            <param name='number'>
            The value for which to get the bit numbers.
            </param>
        </member>
        <member name="T:CSF.IO.FilenameExtensionBuilder">
            <summary>
            A builder which may be used to perform advanced manipulations upon a filename and its extensions.
            </summary>
        </member>
        <member name="P:CSF.IO.FilenameExtensionBuilder.BaseName">
            <summary>
            Gets or sets the base filename (without any extensions).
            </summary>
            <value>The filename.</value>
        </member>
        <member name="P:CSF.IO.FilenameExtensionBuilder.Extensions">
            <summary>
            Gets an ordered collection of the extensions.  This collection is mutable; <c>null</c> extensions are ignored.
            </summary>
            <value>The extensions.</value>
        </member>
        <member name="M:CSF.IO.FilenameExtensionBuilder.ToString">
            <summary>
            Converts the state of the current instance into a <c>System.String</c>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:CSF.IO.IBuildsFilenamesWithExtensions"/>.</returns>
        </member>
        <member name="M:CSF.IO.FilenameExtensionBuilder.#ctor(System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Char)">
            <summary>
            Initializes a new instance of the <see cref="T:CSF.IO.FilenameExtensionBuilder"/> class.
            </summary>
            <param name="baseName">Base name.</param>
            <param name="extensions">Extensions.</param>
            <param name="extensionCharacter">Extension character.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionBuilder.Parse(System.String,System.Char)">
            <summary>
            Parses a given filename and creates an instance of <see cref="T:CSF.IO.FilenameExtensionBuilder"/>.
            </summary>
            <returns>A filename extension builder.</returns>
            <param name="filename">The filename to parse.</param>
            <param name="extensionCharacter">The extension separator character.</param>
        </member>
        <member name="T:CSF.IO.FileSystemInfoExtensions">
            <summary>
            Extension methods for <see cref="T:System.IO.FileSystemInfo"/>.
            </summary>
        </member>
        <member name="M:CSF.IO.FileSystemInfoExtensions.IsChildOf(System.IO.FileSystemInfo,System.IO.DirectoryInfo)">
            <summary>
            Determines whether this instance is child of the specified directory.
            </summary>
            <returns>
            <c>true</c> if this instance is child of the specified directory; otherwise, <c>false</c>.
            </returns>
            <param name='info'>
            The current <see cref="T:System.IO.FileSystemInfo"/> instance.
            </param>
            <param name='directory'>
            The directory to test against.
            </param>
        </member>
        <member name="M:CSF.IO.FileSystemInfoExtensions.GetRelativePath(System.IO.FileSystemInfo,System.IO.DirectoryInfo)">
            <summary>
            Gets a relative path that represents the current instance's relative path from a given <paramref name="root"/>.
            </summary>
            <returns>
            The relative path component.
            </returns>
            <param name='info'>
            The current <see cref="T:System.IO.FileSystemInfo"/> instance.
            </param>
            <param name='root'>
            The root directory from which to create the output
            </param>
            <exception cref='T:System.ArgumentException'>
            Is thrown if the current instance is not a child of the root directory.
            </exception>
        </member>
        <member name="M:CSF.IO.FileSystemInfoExtensions.GetParentDirectory(System.IO.FileSystemInfo)">
            <summary>
            Gets the parent of the current instance, or null if the current instance is the root of its filesystem.
            </summary>
            <returns>
            The parent directory.
            </returns>
            <param name='info'>
            The current <see cref="T:System.IO.FileSystemInfo"/> instance.
            </param>
            <exception cref='T:System.ArgumentNullException'>
            Is thrown when an argument passed to a method is invalid because it is <see langword="null" /> .
            </exception>
        </member>
        <member name="M:CSF.IO.FileSystemInfoExtensions.CreateRecursively(System.IO.DirectoryInfo)">
            <summary>
            Creates a directory recursively, creating parent directories if required.
            </summary>
            <param name="info">Info.</param>
        </member>
        <member name="T:CSF.IO.IManipulatesFilenameExtensions">
            <summary>
            A service which is able to manipulate the extensions of filenames.
            </summary>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.GetLastExtension(System.String)">
            <summary>
            Given a filename which might have zero or more extensions, gets the last extension.
            </summary>
            <remarks>
            <para>
            If the file has only one extension then this returns it.  If it has multiple extensions then only the last one
            is returned.  If the file has no extensions then a <c>null</c> reference is returned.
            </para>
            </remarks>
            <returns>The last extension.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.GetExtensions(System.String)">
            <summary>
            Given a filename which might have zero or more extensions, gets a collection of those extensions.
            </summary>
            <returns>The extensions.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.RemoveLastExtension(System.String)">
            <summary>
            Gets a copy of the given filename, except with the last extension removed.
            </summary>
            <returns>The filename, with the last extension removed.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.RemoveFirstExtension(System.String)">
            <summary>
            Gets a copy of the given filename, except with the first extension removed.
            </summary>
            <returns>The filename, with the first extension removed.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.RemoveExtension(System.String,System.Int32)">
            <summary>
            Gets a copy of the given filename, except with one of the extensions removed.
            </summary>
            <returns>The filename, with the specified extension removed.</returns>
            <param name="filename">Filename.</param>
            <param name="index">The index of the extension to remove.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.ReplaceLastExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, except with the last extension replaced with the specified replacement.
            </summary>
            <returns>The filename, with the last extension replaced.</returns>
            <param name="filename">Filename.</param>
            <param name="newExtension">The replacement extension.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.ReplaceFirstExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, except with the first extension replaced with the specified replacement.
            </summary>
            <returns>The filename, with the first extension replaced.</returns>
            <param name="filename">Filename.</param>
            <param name="newExtension">The replacement extension.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.ReplaceExtension(System.String,System.Int32,System.String)">
            <summary>
            Gets a copy of the given filename, except with one of the extensions replaced with the specified replacement.
            </summary>
            <returns>The filename, with an extension replaced.</returns>
            <param name="filename">Filename.</param>
            <param name="index">The index of the extension to replace.</param>
            <param name="newExtension">The replacement extension.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.AppendExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, with an additional extension added as the new last extension.
            </summary>
            <returns>The modified filename.</returns>
            <param name="filename">Filename.</param>
            <param name="extraExtension">The extension to add.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.PrependExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, with an additional extension added as the new first extension.
            </summary>
            <returns>The modified filename.</returns>
            <param name="filename">Filename.</param>
            <param name="extraExtension">The extension to add.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.InsertExtension(System.String,System.Int32,System.String)">
            <summary>
            Gets a copy of the given filename, with an additional extension added at a specified index.
            </summary>
            <returns>The modified filename.</returns>
            <param name="filename">Filename.</param>
            <param name="index">The index at which to insert the new extension.</param>
            <param name="extraExtension">The extension to add.</param>
        </member>
        <member name="M:CSF.IO.IManipulatesFilenameExtensions.CreateBuilder(System.String)">
            <summary>
            Gets a builder instance which may be used to perform advanced manipulation upon a filename.
            </summary>
            <returns>The builder.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="T:CSF.IO.IBuildsFilenamesWithExtensions">
            <summary>
            A service which can build up a filename and its extensions dynamically.
            </summary>
        </member>
        <member name="P:CSF.IO.IBuildsFilenamesWithExtensions.BaseName">
            <summary>
            Gets or sets the base filename (without any extensions).
            </summary>
            <value>The filename.</value>
        </member>
        <member name="P:CSF.IO.IBuildsFilenamesWithExtensions.Extensions">
            <summary>
            Gets an ordered collection of the extensions.  This collection is mutable; <c>null</c> extensions are ignored.
            </summary>
            <value>The extensions.</value>
        </member>
        <member name="M:CSF.IO.IBuildsFilenamesWithExtensions.ToString">
            <summary>
            Converts the state of the current instance into a <c>System.String</c>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:CSF.IO.IBuildsFilenamesWithExtensions"/>.</returns>
        </member>
        <member name="T:CSF.IO.FilenameExtensionManipulator">
            <summary>
            A service implementation which performs some simple/comment manipulations upon a filename and its extensions.
            </summary>
            <remarks>
            <para>
            Internally, this type makes use of a <see cref="T:CSF.IO.FilenameExtensionBuilder"/> for all of its operations.
            </para>
            </remarks>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.AppendExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, with an additional extension added as the new last extension.
            </summary>
            <returns>The modified filename.</returns>
            <param name="filename">Filename.</param>
            <param name="extraExtension">The extension to add.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.CreateBuilder(System.String)">
            <summary>
            Gets a builder instance which may be used to perform advanced manipulation upon a filename.
            </summary>
            <returns>The builder.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.GetExtensions(System.String)">
            <summary>
            Given a filename which might have zero or more extensions, gets a collection of those extensions.
            </summary>
            <returns>The extensions.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.GetLastExtension(System.String)">
            <summary>
            Given a filename which might have zero or more extensions, gets the last extension.
            </summary>
            <remarks>
            <para>
            If the file has only one extension then this returns it.  If it has multiple extensions then only the last one
            is returned.  If the file has no extensions then a <c>null</c> reference is returned.
            </para>
            </remarks>
            <returns>The last extension.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.InsertExtension(System.String,System.Int32,System.String)">
            <summary>
            Gets a copy of the given filename, with an additional extension added at a specified index.
            </summary>
            <returns>The modified filename.</returns>
            <param name="filename">Filename.</param>
            <param name="index">The index at which to insert the new extension.</param>
            <param name="extraExtension">The extension to add.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.PrependExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, with an additional extension added as the new first extension.
            </summary>
            <returns>The modified filename.</returns>
            <param name="filename">Filename.</param>
            <param name="extraExtension">The extension to add.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.RemoveExtension(System.String,System.Int32)">
            <summary>
            Gets a copy of the given filename, except with one of the extensions removed.
            </summary>
            <returns>The filename, with the specified extension removed.</returns>
            <param name="filename">Filename.</param>
            <param name="index">The index of the extension to remove.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.RemoveFirstExtension(System.String)">
            <summary>
            Gets a copy of the given filename, except with the first extension removed.
            </summary>
            <returns>The filename, with the first extension removed.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.RemoveLastExtension(System.String)">
            <summary>
            Gets a copy of the given filename, except with the last extension removed.
            </summary>
            <returns>The filename, with the last extension removed.</returns>
            <param name="filename">Filename.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.ReplaceExtension(System.String,System.Int32,System.String)">
            <summary>
            Gets a copy of the given filename, except with one of the extensions replaced with the specified replacement.
            </summary>
            <returns>The filename, with an extension replaced.</returns>
            <param name="filename">Filename.</param>
            <param name="index">The index of the extension to replace.</param>
            <param name="newExtension">The replacement extension.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.ReplaceFirstExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, except with the first extension replaced with the specified replacement.
            </summary>
            <returns>The filename, with the first extension replaced.</returns>
            <param name="filename">Filename.</param>
            <param name="newExtension">The replacement extension.</param>
        </member>
        <member name="M:CSF.IO.FilenameExtensionManipulator.ReplaceLastExtension(System.String,System.String)">
            <summary>
            Gets a copy of the given filename, except with the last extension replaced with the specified replacement.
            </summary>
            <returns>The filename, with the last extension replaced.</returns>
            <param name="filename">Filename.</param>
            <param name="newExtension">The replacement extension.</param>
        </member>
        <member name="T:CSF.Fraction">
            <summary>
            <para>
            Representation of a fraction, a rational number with an <see cref="T:System.Int32"/> numerator and an <see cref="T:System.Int32"/>
            denominator.  This type is immutable.
            </para>
            </summary>
        </member>
        <member name="P:CSF.Fraction.Numerator">
            <summary>
            <para>Read-only.  Gets the numerator for the current instance.</para>
            </summary>
        </member>
        <member name="P:CSF.Fraction.Denominator">
            <summary>
            <para>Read-only.  Gets the denoninator for the current instance.</para>
            </summary>
        </member>
        <member name="P:CSF.Fraction.SimplifiesToInteger">
            <summary>
            <para>Read-only.  Determines whether the current instance can be simplified down to an integer value.</para>
            </summary>
        </member>
        <member name="M:CSF.Fraction.Equals(System.Object)">
            <summary>
            <para>Overridden, compares for equality with <paramref name="obj"/>.</para>
            </summary>
            <param name="obj">
            A <see cref="T:System.Object"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.GetHashCode">
            <summary>
            <para>Gets a hash code for the current instance.</para>
            </summary>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.Simplify">
            <summary>
            <para>Creates a copy of the current instance, reduced to its simplest form.</para>
            </summary>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.ToString">
            <summary>
            <para>Creates a string representation of the current instance.</para>
            </summary>
            <remarks>
            <para>
            The formatting of this output will always be <c>x/y</c>, where x and y may be preceded by a negative symbol.
            This formatting can result in vulgar fractions (numerator larger than the denominator).
            </para>
            </remarks>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.ToCompositeString">
            <summary>
            <para>Creates a string representation of the current instance.</para>
            </summary>
            <remarks>
            <para>
            The formatting of this output will always be <c>z x/y</c>, where z is optional and may be preceded by a
            negative symbol and the <c>x/y</c> portion is also optional.
            This formatting will never result in vulgar fractions, since z contains the largest (absolute-value) integer
            that the current instance can create.
            </para>
            <para>
            If the fractional part of this output is missing (IE: only z is written) then the current instance represents
            an integral value.
            </para>
            <para>
            If, alternatively, the integer part of this output is missing (IE: only x/y is written) then the current
            instance represents an absolute value less than one.
            </para>
            </remarks>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.ToDecimal">
            <summary>
            <para>Creates and returns a <see cref="T:System.Decimal"/> representation of the current instance.</para>
            </summary>
            <returns>
            A <see cref="T:System.Decimal"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.ToInteger">
            <summary>
            <para>Creates and returns a <see cref="T:System.Int32"/> representation of the current instance.</para>
            </summary>
            <remarks>
            <para>This is only valid where <see cref="P:CSF.Fraction.SimplifiesToInteger"/> is true.</para>
            </remarks>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.Clone">
            <summary>
            <para>Creates a deep copy of the current instance.</para>
            </summary>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.#ctor(System.Int32,System.Int32)">
            <summary>
            <para>Initialises this instance.</para>
            </summary>
            <param name="numerator">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="denominator">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:CSF.Fraction.Parse(System.String)">
            <summary>
            <para>Parses a <see cref="T:System.String"/> in the format <c>x/y</c> as a <see cref="T:CSF.Fraction"/>.</para>
            </summary>
            <remarks>
            <para>
            Both X and Y in the specification must be integers (positive or negative) and within the range of a signed
            <see cref="T:System.Int32"/>.
            </para>
            </remarks>
            <param name="specification">
            A <see cref="T:System.String"/>
            </param>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.op_Equality(CSF.Fraction,CSF.Fraction)">
            <summary>
            <para>Operator overload for equality.</para>
            </summary>
            <param name="x">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <param name="y">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.op_Inequality(CSF.Fraction,CSF.Fraction)">
            <summary>
            <para>Operator overload for inequality.</para>
            </summary>
            <param name="x">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <param name="y">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.op_Multiply(CSF.Fraction,CSF.Fraction)">
            <summary>
            <para>Operator overload for multiplying fractions together.</para>
            </summary>
            <param name="x">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <param name="y">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.op_Division(CSF.Fraction,CSF.Fraction)">
            <summary>
            <para>Operator overload for dividing fractions by one another.</para>
            </summary>
            <param name="x">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <param name="y">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.op_Addition(CSF.Fraction,CSF.Fraction)">
            <summary>
            <para>Operator overload for adding two fractions together.</para>
            </summary>
            <param name="x">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <param name="y">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="M:CSF.Fraction.op_Subtraction(CSF.Fraction,CSF.Fraction)">
            <summary>
            <para>Operator overload for subtracting one fraction from another.</para>
            </summary>
            <param name="x">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <param name="y">
            A <see cref="T:CSF.Fraction"/>
            </param>
            <returns>
            A <see cref="T:CSF.Fraction"/>
            </returns>
        </member>
        <member name="T:CSF.PrimeFactoriser">
            <summary>
            <para>A utility type for the generation of prime numbers and factorising numbers.</para>
            </summary>
            <remarks>
            <para>
            This type is heavily (almost completely) based on the excellent work found at
            http://handcraftsman.wordpress.com/2010/09/02/ienumerable-of-prime-numbers-in-csharp/ and
            http://handcraftsman.wordpress.com/2010/09/02/prime-factorization-in-csharp/
            </para>
            </remarks>
        </member>
        <member name="M:CSF.PrimeFactoriser.GetCommonPrimeFactors(System.Int32,System.Int32)">
            <summary>
            <para>Gets a collection of the prime factors that are common between two numbers.</para>
            </summary>
            <param name="firstNumber">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="secondNumber">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A collection of <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:CSF.PrimeFactoriser.GetPrimeFactors(System.Int32)">
            <summary>
            <para>Gets a collection of the prime factors of a number.</para>
            </summary>
            <param name="number">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A collection of <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:CSF.PrimeFactoriser.GeneratePrimes(System.Int32)">
            <summary>
            <para>Gets a collection of the prime numbers up to a given ceiling.</para>
            </summary>
            <param name="upTo">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A collection of <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:CSF.PrimeFactoriser.PotentialPrimes(System.Int32)">
            <summary>
            Gets a collection of candidates for prime numbers, up to a given limit.
            </summary>
            <remarks>
            <para>
            This method is an optimisation, Above the number 2 itself, no number divisible by 2 can be a prime number.
            Likewise, above the number 3, no number divisible by 3 can be a prime number.
            </para>
            <para>
            This method returns the numbers 2, then 3, and then a collection of numbers which are one-less-then and then
            one-greater-than multiples of 6.  The multiple of 6 itself is impossible (divides by 2 and 3).  The multiple of
            6 ± two is impossible (it would divide by 2) as is the multiple of 6 ± three (it would divide by 3).
            Once we get to ± four or ± five we are talking about the same number as [a different multiple of 6] ± two or
            ± one (respectively) would result in.
            </para>
            <para>
            Thus, this method cuts the work we must perform to find prime numbers roughly to a third of that which we would
            need if we used a naïve search of the whole integer range.
            </para>
            </remarks>
            <returns>The primes.</returns>
            <param name="upTo">Up to.</param>
        </member>
        <member name="M:CSF.PrimeFactoriser.GetCommonPrimeFactors(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Builds and returns a collection of the prime factors which exist in both first and second collections.
            </summary>
            <remarks>
            <para>
            In this operation, duplicates (which appear in both collections more than once) are included multiple times in
            the output - as many times as they exist in both collections.
            </para>
            <para>
            Note that this method is destructive.  The collection of second prime factors is altered (elements removed) as
            the output is built.  Do not call this when you care that the input parameters are unmodified!
            </para>
            </remarks>
            <returns>The common prime factors.</returns>
            <param name="firstPrimeFactors">First prime factors.</param>
            <param name="secondPrimeFactors">Second prime factors.</param>
        </member>
        <member name="M:CSF.PrimeFactoriser.#ctor">
            <summary>
            <para>Initialises the current instance.</para>
            </summary>
        </member>
        <member name="M:CSF.PrimeFactoriser.#cctor">
            <summary>
            <para>Initialises the singleton <see cref="P:CSF.PrimeFactoriser.Default"/> generator.</para>
            </summary>
        </member>
        <member name="P:CSF.PrimeFactoriser.Default">
            <summary>
            <para>Read-only.  Gets a singleton instance of <see cref="T:CSF.PrimeFactoriser"/>.</para>
            </summary>
        </member>
        <member name="T:CSF.VersionExtensions">
            <summary>
            Container for extension methods to the <see cref="T:System.Version"/> type.
            </summary>
        </member>
        <member name="M:CSF.VersionExtensions.ToSemanticVersion(System.Version)">
            <summary>
            Returns the version number formatted as a "semantic versioning" tag-name.
            </summary>
            <remarks>
            See <c>http://semver.org/</c> for more information about the semantic versioning specification.
            </remarks>
            <returns>
            The semantic version number.
            </returns>
            <param name='version'>
            A <see cref="T:System.Version"/> to operate upon.
            </param>
            <exception cref='T:System.ArgumentNullException'>
            Is thrown when an argument passed to a method is invalid because it is <see langword="null" /> .
            </exception>
        </member>
        <member name="T:CSF.DateTimeEqualityComparer">
            <summary>
            Custom comparison type for comparing equality between <see cref="T:System.DateTime"/> instances.
            </summary>
        </member>
        <member name="P:CSF.DateTimeEqualityComparer.PermittedDifference">
            <summary>
            Gets the permitted difference between dates to be compared.
            </summary>
            <value>
            The permitted difference.
            </value>
        </member>
        <member name="M:CSF.DateTimeEqualityComparer.AreEqual(System.Object,System.Object)">
            <summary>
            Tests for equality between the two objects (which should both be instances of <see cref="T:System.DateTime"/>) within the
            <see cref="P:CSF.DateTimeEqualityComparer.PermittedDifference"/>.
            </summary>
            <param name='obj1'>
            A date/time instance
            </param>
            <param name='obj2'>
            A date/time instance
            </param>
        </member>
        <member name="M:CSF.DateTimeEqualityComparer.AreEqual(System.DateTime,System.DateTime)">
            <summary>
            Tests for equality between the two <see cref="T:System.DateTime"/> instances within the
            <see cref="P:CSF.DateTimeEqualityComparer.PermittedDifference"/>.
            </summary>
            <param name='dateTime1'>
            A date/time instance
            </param>
            <param name='dateTime2'>
            A date/time instance
            </param>
        </member>
        <member name="M:CSF.DateTimeEqualityComparer.GetHashCode(System.Object)">
            <summary>
            Gets the hash code of the given object.
            </summary>
            <param name='obj'>
            An object
            </param>
        </member>
        <member name="M:CSF.DateTimeEqualityComparer.GetHashCode(System.DateTime)">
            <summary>
            Gets the hash code of the given DateTime.
            </summary>
            <param name='obj'>
            An object
            </param>
        </member>
        <member name="M:CSF.DateTimeEqualityComparer.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:CSF.DateTimeEqualityComparer"/> class.
            </summary>
            <param name='permittedDifference'>
            Permitted difference.
            </param>
        </member>
        <member name="T:CSF.Collections.OrderNeutralEqualityComparer`1">
            <summary>
            Equality comparer determines order-neutral equality between collections of items.  That is, that they contain
            the same items, irrespective of order.
            </summary>
        </member>
        <member name="M:CSF.Collections.OrderNeutralEqualityComparer`1.AreEqual(System.Object,System.Object)">
            <summary>
            Determines whether two objects are equal, assuming that they are enumerable collections, ignoring the order of
            elements.
            </summary>
            <returns>
            Whether or not the objects are equal.
            </returns>
            <param name='obj1'>
            The first object to compare.
            </param>
            <param name='obj2'>
            The second object to compare.
            </param>
        </member>
        <member name="M:CSF.Collections.OrderNeutralEqualityComparer`1.AreEqual(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether two objects are equal, assuming that they are enumerable collections, ignoring the order of
            elements.
            </summary>
            <returns>
            Whether or not the objects are equal.
            </returns>
            <param name='enumerable1'>
            The first object to compare.
            </param>
            <param name='enumerable2'>
            The second object to compare.
            </param>
        </member>
        <member name="M:CSF.Collections.OrderNeutralEqualityComparer`1.GetHashCode(System.Object)">
            <summary>
            Unsupported method would get the hash code for an object.
            </summary>
            <param name='obj1'>
            The object for which to get a hash code.
            </param>
        </member>
        <member name="M:CSF.Collections.OrderNeutralEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Gets the hash code for a collection, in an order-neutral manner.
            </summary>
            <param name='enumerable'>
            The object for which to get a hash code.
            </param>
        </member>
        <member name="M:CSF.Collections.OrderNeutralEqualityComparer`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSF.Collections.OrderNeutralEqualityComparer`1"/> class.
            </summary>
        </member>
        <member name="M:CSF.Collections.OrderNeutralEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CSF.Collections.OrderNeutralEqualityComparer`1"/> class.
            </summary>
            <param name="itemComparer">Item comparer.</param>
        </member>
        <member name="T:CSF.Collections.IDictionaryExtensions">
            <summary>
            Extension methods for dictionary types.
            </summary>
        </member>
        <member name="M:CSF.Collections.IDictionaryExtensions.ToNameValueCollection(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Converts a dictionary of strings (string keys and string values) into a <c>NameValueCollection</c> containing
            the same data.
            </summary>
            <returns>
            The name value collection.
            </returns>
            <param name='dictionary'>
            The dictionary to convert.
            </param>
        </member>
        <member name="T:CSF.Collections.IEnumerableExtensions">
            <summary>
            Static helper class containing extension methods for <see cref="T:System.Collections.IEnumerable"/> types.
            </summary>
        </member>
        <member name="M:CSF.Collections.IEnumerableExtensions.AreContentsSameAs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the contents of the <paramref name="source"/> collection are the same as the contents of the
            collection to <paramref name="compareWith"/>.
            </summary>
            <returns>
            <c>true</c> if the two collections contain the same items; <c>false</c> otherwise.
            </returns>
            <param name='source'>
            The source collection to analyse.
            </param>
            <param name='compareWith'>
            The collection to compare with.
            </param>
            <typeparam name='T'>
            The type of item contained within the collections.
            </typeparam>
        </member>
        <member name="M:CSF.Collections.IEnumerableExtensions.AreContentsSameAs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether the contents of the <paramref name="source"/> collection are the same as the contents of the
            collection to <paramref name="compareWith"/>.
            </summary>
            <returns>
            <c>true</c> if the two collections contain the same items; <c>false</c> otherwise.
            </returns>
            <param name='source'>
            The source collection to analyse.
            </param>
            <param name='compareWith'>
            The collection to compare with.
            </param>
            <param name='equalityComparer'>
            The equality comparer to be used to determine equality between items.
            </param>
            <typeparam name='T'>
            The type of item contained within the collections.
            </typeparam>
        </member>
        <member name="M:CSF.Collections.IEnumerableExtensions.CopyToNewArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a copy of the given collection, in a newly-created array.
            </summary>
            <returns>A new array containing the same objects as the source collection in the same order.</returns>
            <param name="source">The source collection.</param>
            <typeparam name="T">The type of the collection items.</typeparam>
        </member>
        <member name="M:CSF.Collections.IEnumerableExtensions.CopyToNewArray``1(``0[])">
            <summary>
            Returns a copy of the given array, in a newly-created array.
            </summary>
            <returns>A new array containing the same objects as the source collection in the same order.</returns>
            <param name="source">The source collection.</param>
            <typeparam name="T">The type of the collection items.</typeparam>
        </member>
        <member name="T:CSF.Collections.CollectionExtensions">
            <summary>
            Extension methods for <c>ICollection</c> instances.
            </summary>
        </member>
        <member name="M:CSF.Collections.CollectionExtensions.ReplaceContents``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Replaces the contents of the given generic <c>ICollection</c> with a given enumerable collection of the same
            type.
            </summary>
            <remarks>
            <para>
            Use this method as an alternative to an assignment operator when an assignment would not be a legal thing to do.
            For example, if the source collection is a read-only property, or there is an important reason that the source
            collection remains the same instance.
            </para>
            <para>
            This method essentially just clears the source collection and then enumerates through the replacement, adding
            every item found.
            </para>
            </remarks>
            <param name='sourceCollection'>
            The collection to have its contents replaced.
            </param>
            <param name='replacementCollection'>
            A collection holding the replacement elements.
            </param>
            <typeparam name='T'>
            The type of item contained by the collection.
            </typeparam>
        </member>
        <member name="T:CSF.DateTimeExtensions">
            <summary>
            Extension methods for the <see cref="T:System.DateTime"/> object.
            </summary>
        </member>
        <member name="M:CSF.DateTimeExtensions.AsAgeInYears(System.DateTime)">
            <summary>
            Returns a value that represents the current instance as an age in years, using the current date as the
            'reference point' (IE: the age in years, as of today).
            </summary>
            <returns>
            The age in years.
            </returns>
            <param name='birthDate'>
            A birth date
            </param>
        </member>
        <member name="M:CSF.DateTimeExtensions.AsAgeInYears(System.DateTime,System.DateTime)">
            <summary>
            Returns a value that represents the current instance as an age in years, using an arbitrary reference date
            (IE: the age in years, as of the reference date).
            </summary>
            <returns>
            The age in years.
            </returns>
            <param name='birthDate'>
            A birth date
            </param>
            <param name='atDate'>
            The reference date
            </param>
        </member>
        <member name="M:CSF.DateTimeExtensions.GetLastDayOfMonth(System.DateTime)">
            <summary>
            Gets a <c>System.DateTime</c> which represents midnight on the last day of the same month represented by the
            given instance.
            </summary>
            <returns>A DateTime representing the last day of the month.</returns>
            <param name="date">Date.</param>
        </member>
        <member name="T:CSF.NullSafe">
            <summary>
            Static convertor type that converts to nullable types, which return a null state if conversion failed.
            </summary>
        </member>
        <member name="M:CSF.NullSafe.ConvertTo``1(System.Object)">
            <summary>
            Converts the specified value to a nullable instance of the specified type.
            </summary>
            <param name='value'>
            The value to convert.
            </param>
            <typeparam name='TDestination'>
            The target/destination type.
            </typeparam>
        </member>
        <member name="T:CSF.StringExtensions">
            <summary>
            Extension methods for the string type.
            </summary>
        </member>
        <member name="M:CSF.StringExtensions.Capitalize(System.String)">
            <summary>
            Capitalizes the specified string.
            </summary>
            <remarks>
            <para>
            The definition of this operation is to firstly convert the entire string to lowercase.  Then, the first
            character of every word is replaced with its uppercase equivalent.
            </para>
            </remarks>
            <param name='value'>
            The string to be capitalized.
            </param>
        </member>
        <member name="M:CSF.StringExtensions.Capitalize(System.String,System.Globalization.CultureInfo)">
            <summary>
            Capitalizes the specified string.
            </summary>
            <remarks>
            <para>
            The definition of this operation is to firstly convert the entire string to lowercase.  Then, the first
            character of every word is replaced with its uppercase equivalent.
            </para>
            </remarks>
            <param name='value'>
            The string to be capitalized.
            </param>
            <param name='culture'>
            The culture to use for any lowercase/uppercase transformations.
            </param>
        </member>
        <member name="M:CSF.StringExtensions.CapitalizeInvariant(System.String)">
            <summary>
            Capitalizes the specified string using the invariant culture.
            </summary>
            <remarks>
            <para>
            The definition of this operation is to firstly convert the entire string to lowercase.  Then, the first
            character of every word is replaced with its uppercase equivalent.
            </para>
            </remarks>
            <param name='value'>
            The string to be capitalized.
            </param>
        </member>
        <member name="M:CSF.StringExtensions.ParseAs``1(System.String)">
            <summary>
            Parses the string as an enumeration member.
            </summary>
            <returns>
            The enumeration member represented by the <paramref name="value"/>.
            </returns>
            <param name='value'>
            The string value to parse.
            </param>
            <typeparam name='TEnum'>
            The target enumeration type.
            </typeparam>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="value"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            If the <paramref name="value"/> does not represent an enumeration constant of the target type.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If the target type is not an enumeration type.
            </exception>
        </member>
        <member name="M:CSF.StringExtensions.ParseAs``1(System.String,System.Boolean)">
            <summary>
            Parses the string as an enumeration member.
            </summary>
            <returns>
            The enumeration member represented by the <paramref name="value"/>.
            </returns>
            <param name='value'>
            The string value to parse.
            </param>
            <param name='ignoreCase'>
            A value that indicates whether the case of the <paramref name="value"/> should be ignored or not.
            </param>
            <typeparam name='TEnum'>
            The target enumeration type.
            </typeparam>
            <exception cref="T:System.ArgumentNullException">
            If the <paramref name="value"/> is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            If the <paramref name="value"/> does not represent an enumeration constant of the target type.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If the target type is not an enumeration type.
            </exception>
        </member>
        <member name="M:CSF.StringExtensions.TryParseAs``1(System.String)">
            <summary>
            Attempts to parse the string as an enumeration member, returning a null reference if parsing fails.
            </summary>
            <returns>
            The enumeration member represented by the <paramref name="value"/>, or a null reference.
            </returns>
            <param name='value'>
            The string value to parse.
            </param>
            <typeparam name='TEnum'>
            The target enumeration type.
            </typeparam>
            <exception cref="T:System.InvalidOperationException">
            If the target type is not an enumeration type.
            </exception>
        </member>
        <member name="M:CSF.StringExtensions.TryParseAs``1(System.String,System.Boolean)">
            <summary>
            Attempts to parse the string as an enumeration member, returning a null reference if parsing fails.
            </summary>
            <returns>
            The enumeration member represented by the <paramref name="value"/>, or a null reference.
            </returns>
            <param name='value'>
            The string value to parse.
            </param>
            <param name='ignoreCase'>
            A value that indicates whether the case of the <paramref name="value"/> should be ignored or not.
            </param>
            <typeparam name='TEnum'>
            The target enumeration type.
            </typeparam>
            <exception cref="T:System.InvalidOperationException">
            If the target type is not an enumeration type.
            </exception>
        </member>
        <member name="T:CSF.EnumExtensions">
            <summary>
            Type containing extension methods that are useful to enumerated types.
            </summary>
            <remarks>
            <para>
            These extension methods are somewhat general for enumerations and do not live in any special namespace.
            </para>
            </remarks>
        </member>
        <member name="M:CSF.EnumExtensions.IsDefinedValue``1(``0)">
            <summary>
            Determines whether the given enumeration value is a defined value of its parent enumeration.
            </summary>
            <c>true</c> if the given value is a defined value of its associated enumeration; otherwise, <c>false</c>.
            <param name="value">The enumeration value to analyse.</param>
            <typeparam name="TEnum">The enumeration type.</typeparam>
        </member>
        <member name="M:CSF.EnumExtensions.RequireDefinedValue``1(``0,System.String)">
            <summary>
            Asserts that the given enumeration value is a defined value of its parent enumeration and raises an
            exception if it is not.
            </summary>
            <exception cref="T:CSF.RequiresDefinedEnumerationConstantException">If the assertion fails.</exception>
            <param name="value">The enumeration value upon which to perform the assertion.</param>
            <param name="name">An object name, to aid in identifying the object should an exception be raised.</param>
            <typeparam name="TEnum">The enumeration type.</typeparam>
        </member>
        <member name="M:CSF.EnumExtensions.WithFlags``1(``0,``0[])">
            <summary>
            Combines a flags-based enumerated value with the given flags, returning the result.
            </summary>
            <returns>
            The original value, with the given flags added.
            </returns>
            <param name='original'>
            The original value (unmodified in this process).
            </param>
            <param name='addedFlags'>
            A collection of the flags to add.
            </param>
            <typeparam name='TEnum'>
            The type of the enumerated value.
            </typeparam>
        </member>
        <member name="M:CSF.EnumExtensions.WithoutFlags``1(``0,``0[])">
            <summary>
            Excludes the given flags from a flags-based enumerated value, returning the result.
            </summary>
            <returns>
            The original value, with the given flags removed.
            </returns>
            <param name='original'>
            The original value (unmodified in this process).
            </param>
            <param name='removedFlags'>
            A collection of the flags to remove.
            </param>
            <typeparam name='TEnum'>
            The type of the enumerated value.
            </typeparam>
        </member>
        <member name="M:CSF.EnumExtensions.GetIndividualValues``1(``0)">
            <summary>
            Breaks a <see cref="T:System.FlagsAttribute"/>-decorated enumeration value down into its component parts and returns
            them,
            </summary>
            <returns>The individual enumeration values.</returns>
            <param name="combinedValue">The combined enumeration value.</param>
            <typeparam name="TEnum">The type of enumeration.</typeparam>
        </member>
        <member name="M:CSF.EnumExtensions.GetFieldInfo``1(``0)">
            <summary>
            Gets a <c>System.Reflection.FieldInfo</c> instance from an enumeration value.
            </summary>
            <returns>
            Information about the member that represents the enumeration value.
            </returns>
            <param name='value'>
            The enumeration value.
            </param>
        </member>
        <member name="M:CSF.EnumExtensions.GetEnumValue(System.Object,System.TypeCode)">
            <summary>
            Gets the numeric equivalent of an enumeration value, given that the enumeration uses the given underlying type.
            </summary>
            <returns>
            The numeric equivalent of the enumeration value.
            </returns>
            <param name='value'>
            The enumeration value.
            </param>
            <param name='underlyingTypeCode'>
            The <c>System.TypeCode</c> of the underlying type of the enumeration.
            </param>
        </member>
        <member name="M:CSF.EnumExtensions.GetEnumValue(System.Object,System.Type)">
            <summary>
            Gets the numeric equivalent of an enumeration value, given that the enumeration uses the given underlying type.
            </summary>
            <returns>
            The numeric equivalent of the enumeration value.
            </returns>
            <param name='value'>
            The enumeration value.
            </param>
            <param name='underlyingType'>
            The underlying type of the enumeration.
            </param>
        </member>
        <member name="M:CSF.EnumExtensions.RequireEnum(System.Type)">
            <summary>
            Asserts that the given type is an enumeration.
            </summary>
            <param name="type">The type to analyse.</param>
        </member>
        <member name="M:CSF.EnumExtensions.RequireFlagsAttribute(System.Type)">
            <summary>
            Asserts that the given type is decorated with <c>FlagsAttribute</c>.
            </summary>
            <param name="type">The type to analyse.</param>
        </member>
        <member name="T:CSF.ExceptionExtensions">
            <summary>
            Extension methods relating to the <c>System.Exception</c> type and subclasses.
            </summary>
        </member>
        <member name="M:CSF.ExceptionExtensions.FixStackTrace``1(``0)">
            <summary>
            Makes a number of attempts to fix an exception's stack trace.
            </summary>
            <remarks>
            <para>
            This method uses a priority-ordered set of attempts to fix the stack trace upon the given exception.  If any
            method fails and returns a null result then the next is attempted.
            </para>
            <list type="number">
            <item>An attempt is made using <see cref="M:FixStackTraceUsingInternalPreserve{TException}"/></item>
            <item>An attempt is made using <see cref="M:FixStackTraceUsingPrepForRemoting{TException}"/></item>
            <item>An attempt is made using <see cref="M:FixStackTraceUsingSerialization{TException}"/></item>
            </list>
            <para>
            If all of these methods fail to return a result then an exception of type
            <see cref="T:CSF.CannotFixStackTraceException"/> is raised.  In this scenario it is likely that the framework
            does not support either of the 'unofficial' mechanisms tried (perhaps we are using Mono and not the official
            .NET framework).  The two methods that these mechanisms use are unsupported internal functionality of the
            framework and could vanish at any time.
            </para>
            <para>
            The last-attempted mechanism should work on just about any exception, as long as it posesses a deserialization
            constructor.  That is, a constructor of the signature
            <c>(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</c>.  If an
            exception possesses such a constructor then this mechanism will work in order to preserve the exception's stack
            trace.
            </para>
            </remarks>
            <returns>
            An exception of the same type as was specified as a parameter.  This exception has its stack trace 'fixed' and
            thus preserved.
            </returns>
            <param name='ex'>
            The exception for which to preserve the stack trace.
            </param>
            <typeparam name='TException'>
            The type of exception.
            </typeparam>
            <exception cref="T:CSF.CannotFixStackTraceException">
            If none of the mechanisms attempted are able to preserve the stack trace, this exception is raised.
            </exception>
        </member>
        <member name="M:CSF.ExceptionExtensions.TryFixStackTrace``1(``0,``0@)">
            <summary>
            Makes a number of attempts to fix an exception's stack trace, this method does not throw an exception if all
            attempts fail.
            </summary>
            <remarks>
            <para>
            In almost all scenarios this method should not be used, instead favouring the method
            <c>FixStackTrace&lt;TException&gt;</c>.  This method exists as a last-ditch way of making a best-efforts attempt
            to fix an exception's stack trace when we cannot be sure that it will be possible to do so.  For example, where
            the developer does not control the exception type to be 'fixed' (such as if it is from a third party library) or
            where it is impossible for some reason to add a deserialisation constructor to the exception type.
            </para>
            <para>
            This method uses a priority-ordered set of attempts to fix the stack trace upon the given exception.  If any
            method fails and returns a null result then the next is attempted.
            </para>
            <list type="number">
            <item>An attempt is made using <see cref="M:FixStackTraceUsingInternalPreserve{TException}"/></item>
            <item>An attempt is made using <see cref="M:FixStackTraceUsingPrepForRemoting{TException}"/></item>
            <item>An attempt is made using <see cref="M:FixStackTraceUsingSerialization{TException}"/></item>
            </list>
            <para>
            If all of these methods fail to return a result then this method will return false and the
            <paramref name="fixedException"/> parameter wille expose the original, unmodified exception.  In this scenario
            it is likely that the framework does not support either of the 'unofficial' mechanisms tried (perhaps we are
            using Mono and not the official .NET framework).  The two methods that these mechanisms use are unsupported
            internal functionality of the framework and could vanish at any time.
            </para>
            <para>
            The last-attempted mechanism should work on just about any exception, as long as it posesses a deserialization
            constructor.  That is, a constructor of the signature
            <c>(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</c>.  If an
            exception possesses such a constructor then this mechanism will work in order to preserve the exception's stack
            trace.
            </para>
            </remarks>
            <returns>
            <c>true</c> if this method successfully fixed the exception's stack trace; <c>false</c> otherwise.
            </returns>
            <param name='ex'>
            The exception for which to preserve the stack trace.
            </param>
            <param name='fixedException'>
            If this method returns <c>true</c>, indicating success, then this parameter exposes the fixed exception
            instance.  If this method returns <c>false</c> then this parameter exposes the original, unmodified exception
            instance.
            </param>
            <typeparam name='TException'>
            The type of exception.
            </typeparam>
        </member>
        <member name="M:CSF.ExceptionExtensions.FixStackTraceUsingInternalPreserve``1(``0)">
            <summary>
            Attempts to fix an exception's stack trace using the <c>InternalPreserveStackTrace</c> method.
            </summary>
            <remarks>
            <para>
            This method should never be called directly, because it is unsafe and makes use of unofficial/unsupported
            internal framework methods.  This means that these methods may not exist in the framework that the application
            is currently running on top of.  This unsupported internal method may even be removed from the official .NET
            framework someday.
            </para>
            <para>
            This method should only ever be used as part of <see cref="M:FixStackTrace{TException}"/>, which makes a number
            of priority-ordered attempts to fix the stack trace, sticking with the one that works.
            </para>
            </remarks>
            <returns>
            If this mechanism of fixing an exception's stack trace worked, then the exception is returned.  If this method
            was unable to fix the stack trace then a null reference is returned.
            </returns>
            <param name='ex'>
            The exception for which to preserve the stack trace.
            </param>
            <typeparam name='TException'>
            The type of exception.
            </typeparam>
        </member>
        <member name="M:CSF.ExceptionExtensions.FixStackTraceUsingPrepForRemoting``1(``0)">
            <summary>
            Attempts to fix an exception's stack trace using the <c>PrepForRemoting</c> method.
            </summary>
            <remarks>
            <para>
            This method should never be called directly, because it is unsafe and makes use of unofficial/unsupported
            internal framework methods.  This means that these methods may not exist in the framework that the application
            is currently running on top of.  This unsupported internal method may even be removed from the official .NET
            framework someday.
            </para>
            <para>
            This method should only ever be used as part of <see cref="M:FixStackTrace{TException}"/>, which makes a number
            of priority-ordered attempts to fix the stack trace, sticking with the one that works.
            </para>
            </remarks>
            <returns>
            If this mechanism of fixing an exception's stack trace worked, then the exception is returned.  If this method
            was unable to fix the stack trace then a null reference is returned.
            </returns>
            <param name='ex'>
            The exception for which to preserve the stack trace.
            </param>
            <typeparam name='TException'>
            The type of exception.
            </typeparam>
        </member>
        <member name="M:CSF.ExceptionExtensions.FixStackTraceUsingSerialization``1(``0)">
            <summary>
            Attempts to fix an exception's stack trace using the 'serialization' method.
            </summary>
            <remarks>
            <para>
            This method should never be called directly, because it will not always succeed - especially with custom
            exception types that do not provide a deserialization constructor.  That deserialization constructor is a
            public constructor of signature:
            <c>(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</c>.
            </para>
            <para>
            The advantage of this method is that it relies only on publicly-available functionality and not
            unofficial/unsupported internal framework methods.  The downside being of course that it does not work for every
            exception type.  Of course - if the developer controls the exception type being 'fixed' then they could always
            add a deserialization constructor.
            </para>
            <para>
            This method should only ever be used as part of <see cref="M:FixStackTrace{TException}"/>, which makes a number
            of priority-ordered attempts to fix the stack trace, sticking with the one that works.
            </para>
            <para>
            Credit where it's due; this method almost direct copy-paste of the following StackOverflow answer:
            http://stackoverflow.com/a/2085377
            </para>
            </remarks>
            <returns>
            If this mechanism of fixing an exception's stack trace worked, then the exception is returned.  If this method
            was unable to fix the stack trace then a null reference is returned.
            </returns>
            <param name='ex'>
            The exception for which to preserve the stack trace.
            </param>
            <typeparam name='TException'>
            The type of exception.
            </typeparam>
        </member>
        <member name="M:CSF.ExceptionExtensions.GetInternalPreserveStackTrace">
            <summary>
            Creates a cached delegate that represents the internal <c>Exception.InternalPreserveStackTrace</c> method.
            </summary>
            <returns>
            A delegate instance, or a null reference if the method does not exist.
            </returns>
        </member>
        <member name="M:CSF.ExceptionExtensions.GetPrepForRemoting">
            <summary>
            Creates a cached delegate that represents the internal <c>Exception.PrepForRemoting</c> method.
            </summary>
            <returns>
            A delegate instance, or a null reference if the method does not exist.
            </returns>
        </member>
        <member name="M:CSF.ExceptionExtensions.#cctor">
            <summary>
            Initializes the <see cref="T:CSF.ExceptionExtensions"/> type, initialising cached delegates for the internal
            methods used by this type.
            </summary>
        </member>
        <member name="T:CSF.CannotFixStackTraceException">
            <summary>
            An exception thrown when <see cref="M:ExceptionExtensions.FixStackTrace{TException}"/> is unable to use any
            mechanism to fix an exception's stack trace.
            </summary>
        </member>
        <member name="M:CSF.CannotFixStackTraceException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CannotFixStackTraceException"/> class
            </summary>
        </member>
        <member name="M:CSF.CannotFixStackTraceException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CannotFixStackTraceException"/> class
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the exception. </param>
        </member>
        <member name="M:CSF.CannotFixStackTraceException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:CannotFixStackTraceException"/> class
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the exception. </param>
            <param name="inner">The exception that is the cause of the current exception. </param>
        </member>
        <member name="M:CSF.CannotFixStackTraceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:CannotFixStackTraceException"/> class
            </summary>
            <param name="context">The contextual information about the source or destination.</param>
            <param name="info">The object that holds the serialized object data.</param>
        </member>
        <member name="T:CSF.IGuidGenerationStrategy">
            <summary>
            Interface for a service that generates GUIDs using a defined strategy.
            </summary>
        </member>
        <member name="M:CSF.IGuidGenerationStrategy.Generate">
            <summary>
            Generate a new GUID using the current strategy.
            </summary>
        </member>
        <member name="T:CSF.DefaultGuidStrategy">
            <summary>
            Default implementation of <see cref="T:CSF.IGuidGenerationStrategy"/> that generates default GUIDs.
            </summary>
        </member>
        <member name="M:CSF.DefaultGuidStrategy.Generate">
            <summary>
             Generate a new GUID using the current strategy. 
            </summary>
        </member>
        <member name="T:CSF.BinaryGuidCombStrategy">
            <summary>
            GUID generator that uses the COMB strategy.
            </summary>
        </member>
        <member name="M:CSF.BinaryGuidCombStrategy.Generate">
            <summary>
            Generate a new COMB-based GUID.
            </summary>
        </member>
        <member name="M:CSF.BinaryGuidCombStrategy.Generate(System.DateTime)">
            <summary>
            Generate a GUID using this strategy, for the given timestamp.
            </summary>
            <param name='forTimestamp'>
            The timestamp for which to generate a GUID.
            </param>
        </member>
        <member name="M:CSF.BinaryGuidCombStrategy.#ctor(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSF.BinaryGuidCombStrategy"/> class.
            </summary>
            <param name='nonRandomByteCount'>
            The count of non-random bytes to take from the timestamp.
            </param>
            <param name='placeNonRandomBytesFirst'>
            A value indicating whether non-random bytes should be placed first or last in the resulting GUID.
            </param>
            <param name='nonRandomBytesBigEndian'>
            A value indicating whether or not the random bytes should be stored in a big-endian fashion.
            </param>
        </member>
        <member name="T:CSF.GuidExtensions">
            <summary>
            Extension methods for the <c>System.Guid</c> type.
            </summary>
        </member>
        <member name="M:CSF.GuidExtensions.ToRFC4122ByteArray(System.Guid)">
            <summary>
            Returns a byte array representing the given <c>System.Guid</c> in an RFC-4122 compliant format.
            </summary>
            <remarks>
            <para>
            The rationale for this method (and the reason for requiring it) is because Microsoft internally represent the
            GUID structure in a manner which does not comply with RFC-4122's definition of a UUID.  The first three blocks
            of data (out of 4 total) are stored using the machine's native endianness.  The RFC defines that these three
            blocks should be represented in big-endian format.  This does not cause a problem when getting a
            string-representation of the GUID, since the framework automatically converts to big-endian format before
            formatting as a string.  When getting a byte array equivalent of the GUID though, it can cause issues if the
            recipient of that byte array expects a standards-compliant UUID.
            </para>
            <para>
            This method checks the architecture of the current machine.  If it is little-endian then - before returning a
            value - the byte-order of the first three blocks of data are reversed.  If the machine is big-endian then the
            bytes are left untouched (since they are already correct).
            </para>
            <para>
            For more information, see https://en.wikipedia.org/wiki/Globally_unique_identifier#Binary_encoding
            </para>
            </remarks>
            <returns>
            A byte array representation of the GUID, in RFC-4122 compliant form.
            </returns>
            <param name='guid'>
            The GUID for which to get the byte array.
            </param>
        </member>
        <member name="M:CSF.GuidExtensions.FromRFC4122ByteArray(System.Byte[])">
            <summary>
            Returns a <c>System.Guid</c>, created from the given RFC-4122 compliant byte array.
            </summary>
            <remarks>
            <para>
            The rationale for this method (and the reason for requiring it) is because Microsoft internally represent the
            GUID structure in a manner which does not comply with RFC-4122's definition of a UUID.  The first three blocks
            of data (out of 4 total) are stored using the machine's native endianness.  The RFC defines that these three
            blocks should be represented in big-endian format.  This does not cause a problem when getting a
            string-representation of the GUID, since the framework automatically converts to big-endian format before
            formatting as a string.  When getting a byte array equivalent of the GUID though, it can cause issues if the
            recipient of that byte array expects a standards-compliant UUID.
            </para>
            <para>
            This method checks the architecture of the current machine.  If it is little-endian then - before returning a
            value - the byte-order of the first three blocks of data are reversed.  If the machine is big-endian then the
            bytes are left untouched (since they are already correct).
            </para>
            <para>
            For more information, see https://en.wikipedia.org/wiki/Globally_unique_identifier#Binary_encoding
            </para>
            </remarks>
            <returns>
            A GUID, created from the given byte array.
            </returns>
            <param name='guidBytes'>
            A byte array representing a GUID, in RFC-4122 compliant form.
            </param>
        </member>
        <member name="M:CSF.GuidExtensions.ReorderBytes(System.Byte[])">
            <summary>
            Copies a byte array that represents a GUID, reversing the order of the bytes in data-blocks one to three.
            </summary>
            <returns>
            A copy of the original byte array, with the modifications.
            </returns>
            <param name='guidBytes'>
            A byte array representing a GUID.
            </param>
        </member>
        <member name="T:CSF.Resources.ExceptionMessages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.AlphabeticReferenceMustBeInValidFormat">
            <summary>
              Looks up a localized string similar to The alphabetic reference must be in a valid format..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.CannotCreateRootOfFilesystemFormat">
            <summary>
              Looks up a localized string similar to Cannot create a directory corresponding to the root of a file system: {0}.
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.CannotCreateZeroBasedNegativeAlphabeticReference">
            <summary>
              Looks up a localized string similar to Creating alphabetic references for negative integers is not supported when the reference is to be zero-based..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.CannotFixStackTrace">
             <summary>
               Looks up a localized string similar to An exception was thrown and attempts were made to &apos;fix&apos;/preserve its stack trace, these attempts failed.
            Try adding a constructor of signature (SerializationInfo, StreamingContext) to the inner exception type.
            If this is impossible then you cannot use FixStackTrace on exceptions of this type on the current platform, use TryFixStackTrace instead..
             </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.CountOfGuidNonRandomBytesOutOfRangeFormat">
            <summary>
              Looks up a localized string similar to The count of non-random bytes must be between {0} and {1} (inclusive)..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.CurrentCharacterPositionMustNotBeNegative">
            <summary>
              Looks up a localized string similar to The current character position must not be less than zero..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.EmptyStringNotPermittedForZeroBasedReferences">
            <summary>
              Looks up a localized string similar to An empty string may represent zero in non-zero-based scenarios but it is not permitted in zero-based scenarios..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.FileBaseNameMustNotBeEmpty">
            <summary>
              Looks up a localized string similar to The base filename must not be an empty string..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.FilenameMustNotBeEmpty">
            <summary>
              Looks up a localized string similar to The filename must not be an empty string..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.FractionDenominatorCannotBeZero">
            <summary>
              Looks up a localized string similar to A fraction denominator cannot be zero..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.FractionMustSimplifyToInteger">
            <summary>
              Looks up a localized string similar to This operation is only valid for fractions simplify to an integer..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.IntegerValueMustNotBeLessThanOneForNonZeroBasedOperations">
            <summary>
              Looks up a localized string similar to The absolute integer value to convert to an alphabetic reference must not be less than one for non-zero-based operations..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.IntegerValueMustNotBeLessThanZero">
            <summary>
              Looks up a localized string similar to The absolute integer value to convert to an alphabetic reference must not be less than zero..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.InvalidFractionFormat">
            <summary>
              Looks up a localized string similar to The string must a correctly-formatted fraction..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.MustBeChildOfRootFormat">
            <summary>
              Looks up a localized string similar to The value of parameter &apos;{0}&apos; must be a child of the parameter &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.MustBeDecoratedWithFlagsAttribute">
             <summary>
               Looks up a localized string similar to This operation is only supported for enumerations decorated with `{0}&apos;.
            Unsupported type:`{1}&apos;.
             </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.MustBeEnumerationConstantDefaultMessage">
            <summary>
              Looks up a localized string similar to The value must be a defined member of the enumeration..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.MustBeEnumerationConstantFormat">
             <summary>
               Looks up a localized string similar to The value must be a defined member of the enumeration `{1}&apos;.
            Name:{0}.
             </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.MustBeSixteenBytesInAGuid">
            <summary>
              Looks up a localized string similar to Arrays representing GUIDs must contain exactly 16 bytes..
            </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.OnlySupportedForEnumTypesFormat">
             <summary>
               Looks up a localized string similar to This operation is only supported for types which represent enumerations.
            Unsupported type:`{0}&apos;.
             </summary>
        </member>
        <member name="P:CSF.Resources.ExceptionMessages.TypeCodeMustBeValid">
            <summary>
              Looks up a localized string similar to The `{0}&apos; must be valid for an enumeration..
            </summary>
        </member>
        <member name="T:CSF.RequiresDefinedEnumerationConstantException">
            <summary>
            Exception raised when an enumeration value is required to be a defined enumeration constant, but it is not.
            </summary>
        </member>
        <member name="P:CSF.RequiresDefinedEnumerationConstantException.Message">
            <summary>
            Gets the exception message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="M:CSF.RequiresDefinedEnumerationConstantException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:RequiresDefinedEnumerationConstantException"/> class
            </summary>
        </member>
        <member name="M:CSF.RequiresDefinedEnumerationConstantException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:RequiresDefinedEnumerationConstantException"/> class
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the exception. </param>
        </member>
        <member name="M:CSF.RequiresDefinedEnumerationConstantException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:RequiresDefinedEnumerationConstantException"/> class
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the exception. </param>
            <param name="inner">The exception that is the cause of the current exception. </param>
        </member>
        <member name="M:CSF.RequiresDefinedEnumerationConstantException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CSF.RequiresDefinedEnumerationConstantException"/> class.
            </summary>
            <param name="enumerationType">The enumeration type.</param>
            <param name="name">The name of the value.</param>
        </member>
        <member name="M:CSF.RequiresDefinedEnumerationConstantException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:RequiresDefinedEnumerationConstantException"/> class
            </summary>
            <param name="context">The contextual information about the source or destination.</param>
            <param name="info">The object that holds the serialized object data.</param>
        </member>
        <member name="T:CSF.Globalization.CultureInfoExtensions">
            <summary>
            Extension methods for a calendar object.
            </summary>
        </member>
        <member name="M:CSF.Globalization.CultureInfoExtensions.GetAllMonths(System.Globalization.CultureInfo)">
            <summary>
            Gets all of the months in the year and their names.
            </summary>
            <returns>
            The months in the year.
            </returns>
            <param name='culture'>
            Culture information, relating to which culture to return this information in.
            </param>
        </member>
        <member name="M:CSF.Globalization.CultureInfoExtensions.GetAllMonths(System.Globalization.CultureInfo,System.Int32)">
            <summary>
            Gets all of the months in the year and their names.
            </summary>
            <returns>
            The months in the year.
            </returns>
            <param name='culture'>
            Culture information, relating to which culture to return this information in.
            </param>
            <param name='year'>
            The year for which we want the months data.
            </param>
        </member>
    </members>
</doc>
