<!doctype html>
<html tal:define="activePage string:csharp_expressions">
<head metal:use-macro="documents/Shared/general-page.html/macros/common_document_head">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="utf-8">
<title metal:fill-slot="document_title">TALES 'csharp' expressions</title>
<base href="../" />
<style type="text/css">
@import url(css/styles.css);
@import url(css/dummy.css);
</style>
<script data-main="js/config/main" type="text/javascript" src="js/lib/require.min.js"></script>
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/default.min.css">
</head>
<body metal:use-macro="documents/Shared/general-page.html/macros/common_document_body" class="page_csharp_expressions">
<div class="content_wrapper">
  <header class="page_header dummy">
    Dummy content
  </header>
  <div class="main_page_area">
    <nav>
      <h2>Navigation menu</h2>
      <ul class="active_introduction dummy">
        <li class="introduction"><a href=".">Introduction</a></li>
        <li class="other_page"><a href="dummy.html">Dummy page</a></li>
      </ul>
    </nav>
    <section class="main_page_content" metal:fill-slot="main_page_content">
      <header>
        <div class="expression plugin_note note"
             metal:use-macro="documents/Shared/plugin_note.html/macros/expression_plugin_note">
          <p>
            Expression evaluator plugin notice.
          </p>
          Assembly: <span metal:fill-slot="plugin_assembly"><code>CSF.Zpt.ExpressionEvaluators.CSharpExpressions.dll</code></span><br />
          Class: <span metal:fill-slot="plugin_class"><code>CSF.Zpt.ExpressionEvaluators.CSharpExpressions.CSharpExpressionEvaluator</code></span><br />
          Prefix: <span metal:fill-slot="expression_prefix"><code>csharp:</code></span>
        </div>
        <h1>TALES 'csharp' expressions</h1>
      </header>
      <p>
        <code>csharp:</code> expressions permit the use of C♯ as a mechanism of evaluating TALES expressions.
        The provided C♯ expression string is executed, its value determined and returned as the result of the
        expression.
      </p>
      <h2>Permitted expressions</h2>
      <p>
        C♯ expressions supported by this plugin must be single statements.  Multiple statements (joined by semicolons)
        are not permitted and will not compile.
        Expressions have access to all of the variables which are available to TALES, including those created by
        <code><a href="tal/define.html">tal:define</a></code> and <code><a href="tal/repeat.html">tal:repeat</a></code>
        attributes.
      <p>
      <p>
        In essence, to determine whether an expression is OK or not, consider whether it would be valid for
        execution if preceded by a <code>return</code> keyword and followed by a semicolon, assuming that all of the
        TALES variables are also available in the same scope:
      </p>
      <pre><code class="csharp">return YOUR_EXPRESSION_HERE;</code></pre>
      <h2>Example</h2>
      <pre><code class="html">&lt;div tal:define="myName string:sally"&gt;
  Hello, my name is
  &lt;span tal:replace="csharp:myName.ToUpperInvariant()"&gt;JOSEPH&lt;/span&gt;
&lt;/div&gt;</code></pre>
      <p>
        The expression above would emit <kbd>Hello, my name is SALLY</kbd>, surrounded with HTML <code>&lt;div&gt;</code>
        tags.
      </p>
      <h2>Note on variable names</h2>
      <p>
        If this plugin is installed <em>(by default, it is)</em> then all variable names created through
        <code><a href="tal/define.html">tal:define</a></code> or <code><a href="tal/repeat.html">tal:repeat</a></code>
        <em>must also be valid C♯ variable names</em>.
      </p>
      <p>
        For example, on its own, the TALES specification would permit a variable named <kbd>12things</kbd>;
        this is not a valid C♯ variable name though.
        If such a variable is 'in scope' when a <code>csharp:</code> expression is evaluated, the expression will
        not compile and an error will be raised.
        <em>It does not matter whether the C♯ expression attempts to make use of such a 'bad' variable or not</em>.
        The very presence of the variable in the TALES environment will prevent the C♯ expression from compiling.
      </p>
      <h2>Reminder: HTML encoding</h2>
      <p>
        Because TALES expressions (including C♯ expressions) are specified within the source document, in the source
        document's own syntax, you must adhere to that document's escaping/encoding rules.  In particular this applies
        to double-quote characters, which must be specified as <kbd>&amp;quot;</kbd>, greater-than
        (<kbd>&amp;gt;</kbd>), less-than (<kbd>&amp;lt;</kbd>) and ampersands (<kbd>&amp;amp;</kbd>).
      </p>
      <p>
        This is illustrated in the following example, where <code>DateTime.ToString</code> is used with a
        string parameter to get a custom date format.
      </p>
      <pre><code class="html">&lt;p tal:define="today csharp:DateTime.Today"&gt;
  Today's date is
  &lt;span tal:content="csharp:today.ToString(&amp;quot;yyyy-MM-dd&amp;quot;)"&gt;2012-01-01&lt;span&gt;
&lt;/p&gt;</code></pre>
      <h2>Expression internals</h2>
      <p>
        Internally, to provide C♯ expressions,
        <a href="https://msdn.microsoft.com/en-us/library/y2k85ax6(v=vs.110).aspx">the CodeDOM API</a>
        is used.
        Each expression is compiled into a generated class, in an in-memory .NET assembly.
      </p>
      <p>
        Each TALES variable which is in-scope for the expression is provided as a private member field
        of that class.  To simplify variable access these private fields are typed using the <code>dynamic</code>
        keyword.  This means that for general usage their type does not need to known.
      </p>
      <p>
        A limitation of this approach though is for using <strong>extension methods</strong>, including Linq methods
        such as <code>.Sum()</code> or <code>.Count()</code>; these are incompatible with dynamically-typed variables.
        To use these we must
        <a href="tales/advanced-csharp-expressions.html">exert more control over the code which is compiled for the
        C♯ expression</a>.
      </p>
      <h3>Consider moving complex expressions into your model</h3>
      <p>
        Please note that whilst the functionality exists to import .NET namespaces, specify referenced assemlies and
        to indicate the type of variables, it may be far simpler to push such functionality downwards into your MVC
        model.  If for example you wish to write something along the lines of the following:
      </p>
      <pre><code class="html">&lt;p tal:define="itemCount csharp:here.Items.Count(x => x.Colour == &amp;quot;Red&amp;quot;)"&gt;
  There are &lt;span tal:replace="itemCount"&gt;3&lt;/span&gt; red items
&lt;p&gt;</code></pre>
      <p>
        <em>This expression will not compile</em> without specifying the type (such as
        <code>IEnumerable&lt;MyItemType&gt;</code>) of the <code>Items</code> model property.
        This will likely require some namespace imports and an assembly reference.
      </p>
      <p>
        Instead consider removing the need for any of this by providing a <code>GetItemCount(string colour)</code> method
        on your MVC model.  This would work around the need to include the extra markup in your view, and makes the
        whole solution far more clean.  In short - whilst the functionality exists to enable extension methods &amp;
        Linq in ZPT views, it tends to be best to avoid it if you don't have to use it.
      </p>
    </section>
  </div>
</div>
<footer class="page_footer dummy">
  Dummy content
</footer>
</body>
</html>
